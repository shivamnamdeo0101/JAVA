package JAVA_1_MEMO_JDK_GC;
// ================================================================================
// JAVA MEMORY & JVM â€” STRUCTURED, DETAILED, BULLET-POINT EXPLANATION (ONE WINDOW)
// ================================================================================

// JVM ARCHITECTURE
// --------------------------------------------------------------------------------
// â€¢ The Java Virtual Machine (JVM) is the runtime engine that executes Java bytecode
//   and enables platform independence by abstracting the underlying OS and hardware.
// â€¢ The JVM is responsible for loading classes, verifying bytecode, managing memory,
//   executing instructions, handling threads, and running garbage collection.
// â€¢ Java source code is compiled into platform-independent bytecode, which the JVM
//   interprets or compiles into native machine code at runtime.

// JDK vs JRE vs JVM
// --------------------------------------------------------------------------------
// â€¢ The Java Development Kit (JDK) is used for development and includes the Java
//   compiler, debugging tools, monitoring utilities, and a complete JRE.
// â€¢ The Java Runtime Environment (JRE) is used only for running applications and
//   contains the JVM along with core Java libraries.
// â€¢ The JVM is the core component that actually executes bytecode and manages memory.
// â€¢ Developers install the JDK, while production systems typically require only JRE.

// CLASSLOADER SUBSYSTEM
// --------------------------------------------------------------------------------
// â€¢ The ClassLoader subsystem dynamically loads Java classes into memory when they
//   are first referenced, instead of loading all classes at startup.
// â€¢ The Bootstrap ClassLoader loads core Java classes such as java.lang.Object and
//   is implemented in native code, making it trusted by the JVM.
// â€¢ The Extension ClassLoader loads platform extension libraries that enhance the
//   core Java API but are not part of the standard library.
// â€¢ The Application ClassLoader loads user-defined classes from the classpath and
//   handles almost all application-level code.
// â€¢ The parent-delegation model ensures security by preventing applications from
//   overriding core Java classes.

// HEAP MEMORY
// --------------------------------------------------------------------------------
// â€¢ Heap memory is a shared runtime area where all Java objects and instance variables
//   are stored and accessed by all application threads.
// â€¢ The heap is divided into generations to optimize garbage collection based on
//   object lifetime characteristics.
// â€¢ The Young Generation stores newly created objects and consists of Eden and two
//   Survivor spaces.
// â€¢ Objects are first allocated in Eden space because most objects are short-lived.
// â€¢ Objects that survive a Minor Garbage Collection are moved to Survivor spaces.
// â€¢ Objects that survive multiple Minor GCs are promoted to the Old Generation.
// â€¢ The Old Generation stores long-lived objects such as caches and session data.

// STACK MEMORY
// --------------------------------------------------------------------------------
// â€¢ Stack memory is thread-private and each thread has its own stack.
// â€¢ The stack stores method call frames, local variables, primitive values, and
//   object references.
// â€¢ Each method invocation creates a new stack frame that is removed once the
//   method completes execution.
// â€¢ Stack memory is managed automatically and is not controlled by garbage collection.
// â€¢ Stack operations are fast because memory allocation and deallocation follow
//   a strict LIFO (Last In First Out) order.

// METASPACE
// --------------------------------------------------------------------------------
// â€¢ Metaspace stores class metadata including class structure, method definitions,
//   field information, and constant pool data.
// â€¢ Metaspace is allocated in native memory instead of heap memory.
// â€¢ Unlike PermGen, Metaspace can grow dynamically until it reaches system limits.
// â€¢ Excessive class loading or ClassLoader leaks can cause Metaspace OutOfMemoryError.

// CODE CACHE
// --------------------------------------------------------------------------------
// â€¢ Code Cache stores native machine code generated by the Just-In-Time (JIT) compiler.
// â€¢ Frequently executed bytecode (hot code) is compiled into native instructions to
//   improve execution performance.
// â€¢ If the Code Cache becomes full, the JVM may disable further JIT compilation,
//   causing performance degradation.

// GARBAGE COLLECTION
// --------------------------------------------------------------------------------
// â€¢ Garbage Collection is an automatic process that identifies and removes objects
//   that are no longer reachable by the application.
// â€¢ The JVM determines object liveness using reachability analysis starting from
//   GC Roots such as stack references and static variables.
// â€¢ Minor GC cleans the Young Generation and occurs frequently.
// â€¢ Major or Full GC cleans the Old Generation and is more expensive.

// GC ALGORITHMS
// --------------------------------------------------------------------------------
// â€¢ The Mark phase identifies all objects that are still reachable.
// â€¢ The Sweep phase removes unreachable objects from memory.
// â€¢ The Compact phase rearranges objects to eliminate memory fragmentation.
// â€¢ Young Generation GC typically uses a copying algorithm.
// â€¢ Old Generation GC uses mark-sweep-compact algorithms.

// GC TYPES
// --------------------------------------------------------------------------------
// â€¢ Serial GC uses a single thread for garbage collection and is suitable for small
//   applications.
// â€¢ Parallel GC uses multiple GC threads to improve throughput.
// â€¢ CMS GC minimizes pause times but can cause fragmentation and is deprecated.
// â€¢ G1 GC divides the heap into regions and provides predictable pause times.
// â€¢ ZGC and Shenandoah perform most GC work concurrently to achieve ultra-low latency.

// STOP-THE-WORLD (STW)
// --------------------------------------------------------------------------------
// â€¢ Stop-The-World is a JVM event during which all application threads are paused.
// â€¢ Threads are not placed in WAITING or BLOCKED states but are frozen by the JVM.
// â€¢ STW ensures memory consistency while the Garbage Collector performs critical work.
// â€¢ Minor and Major garbage collections both involve STW pauses.
// â€¢ Modern GC algorithms aim to minimize the duration of STW pauses.

// MEMORY LEAKS
// --------------------------------------------------------------------------------
// â€¢ A memory leak occurs when objects are no longer needed but are still referenced.
// â€¢ Common causes include static collections, unclosed resources, and listener leaks.
// â€¢ Memory leaks cause increasing heap usage and frequent garbage collection cycles.
// â€¢ Prolonged memory leaks eventually result in OutOfMemoryError.

// OUTOFMEMORYERROR
// --------------------------------------------------------------------------------
// â€¢ OutOfMemoryError occurs when the JVM cannot allocate required memory.
// â€¢ Heap space errors occur due to excessive object creation or memory leaks.
// â€¢ Metaspace errors occur due to excessive class loading.
// â€¢ GC overhead errors occur when the JVM spends most of its time performing GC.

// STACKOVERFLOWERROR
// --------------------------------------------------------------------------------
// â€¢ StackOverflowError occurs when stack memory exceeds its allocated limit.
// â€¢ The most common cause is infinite or excessively deep recursion.
// â€¢ Unlike OutOfMemoryError, StackOverflowError is related to stack memory only.

// FINAL REAL-WORLD SUMMARY
// --------------------------------------------------------------------------------
// â€¢ Heap stores objects and is managed by garbage collection.
// â€¢ Stack stores execution context and is thread-private.
// â€¢ Metaspace stores class metadata and grows dynamically.
// â€¢ Code Cache improves performance through JIT compilation.
// â€¢ GC reclaims unused memory automatically.
// â€¢ STW pauses threads briefly to ensure safe memory management.

// ================================================================================
// END â€” JVM MEMORY EXPLAINED CLEARLY, STRUCTURED, AND INTERVIEW-READY
// ================================================================================




/*
================================================================================
ğŸ”¥ JAVA EXECUTION, JDK / JRE / JVM, MEMORY, GC â€” MASTER CHEAT-SHEET (ONE WINDOW)
Author  : Shivam
Purpose : End-to-End Java understanding (Execution â†’ Memory â†’ GC â†’ Internals)
Use     : Interview prep + real-world mental model
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1ï¸âƒ£ WHAT HAPPENS WHEN YOU RUN A JAVA PROGRAM (COMPLETE FLOW)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Source Code
-----------
Shivam.java
    â”‚
    â”‚ javac (Compiler â€“ part of JDK/bin)
    â–¼
Shivam.class
â†’ BYTECODE (Platform Independent)

Execution
---------
java Shivam
    â”‚
    â–¼
JVM Process Starts (OS-level process)
    â”‚
    â”œâ”€ ClassLoader Subsystem
    â”‚   â”œâ”€ Bootstrap  â†’ loads java.base (Object, String, System)
    â”‚   â”œâ”€ Platform   â†’ loads standard Java libs
    â”‚   â””â”€ App        â†’ loads user classes (Shivam.class)
    â”‚
    â”œâ”€ Bytecode Verifier
    â”‚   â”œâ”€ Stack safety check
    â”‚   â”œâ”€ Access control
    â”‚   â””â”€ Prevents memory corruption
    â”‚
    â”œâ”€ Execution Engine
    â”‚   â”œâ”€ Interpreter â†’ executes bytecode line-by-line
    â”‚   â””â”€ JIT Compiler â†’ hot code â†’ native machine code
    â”‚
    â–¼
CPU executes native instructions
    â–¼
Program Output

ğŸ‘‰ Key Idea:
â€¢ Bytecode is portable
â€¢ JVM is platform dependent
â€¢ Performance improves over time due to JIT

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2ï¸âƒ£ JDK / JRE / JVM â€” CLEAR DIFFERENCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

JDK (Java Development Kit)
â€¢ Used for DEVELOPMENT
â€¢ Contains:
  - javac (compiler)
  - java (launcher)
  - jar, javadoc, jdb, jshell
  - jmods (runtime modules)
  - JVM (libjvm)

JRE (Java Runtime Environment)
â€¢ Used for RUNNING applications
â€¢ Contains:
  - JVM
  - Core libraries (java.lang, java.util, java.ioâ€¦)

JVM (Java Virtual Machine)
â€¢ Used for EXECUTION
â€¢ Responsibilities:
  - Load classes
  - Verify bytecode
  - Manage memory
  - Run GC
  - Execute bytecode

ğŸ‘‰ Relation:
JDK = JRE + Dev Tools
JRE = JVM + Runtime Libraries

/*

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3ï¸âƒ£ JVM INTERNAL ARCHITECTURE + MEMORY + OS + CPU (WHAT RUNS WHERE & WHEN)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

JVM PROCESS (Runs as OS Process)
â”‚ // JVM itself is an OS-level process
â”‚ // OS allocates RAM + CPU time to JVM
â”‚
â”œâ”€â”€ Class Loader Subsystem
â”‚   â”‚ // Uses OS RAM (via JVM)
â”‚   â”‚
â”‚   â”œâ”€ Bootstrap ClassLoader
â”‚   â”‚   // Loads core Java classes (Object, String) example: java.base â†’ java.lang, java.util, java.io
â”‚   â”‚   // Implemented in native code (C/C++)
â”‚   â”‚   // Classes metadata stored in Metaspace (RAM)
â”‚   â”‚
â”‚   â”œâ”€ Platform ClassLoader
â”‚   â”‚   // Loads standard Java libraries  java.sql, java.xml, java.logging
â”‚   â”‚   // Metadata stored in Metaspace (RAM) 
â”‚   â”‚
â”‚   â””â”€ Application ClassLoader
â”‚       // Loads user classes from classpath / JAR - EX:  User defined classes
â”‚       // Metadata stored in Metaspace (RAM)
â”‚
â”œâ”€â”€ Runtime Data Areas (ALL CREATED IN RAM)
â”‚   â”‚
â”‚   â”œâ”€ Stack (Per Thread)
â”‚   â”‚   // Allocated in OS RAM
â”‚   â”‚   // One Stack per Thread
â”‚   â”‚   // Created when thread starts
â”‚   â”‚   // Stores method frames
â”‚   â”‚   // Frame contains:
â”‚   â”‚   // - Local primitive variables (values)
â”‚   â”‚   // - References to Heap objects
â”‚   â”‚   // Destroyed when method returns
â”‚   â”‚   // NOT managed by GC
â”‚   â”‚
â”‚   â”œâ”€ Heap (Shared Across Threads)
â”‚   â”‚   // Allocated in OS RAM
â”‚   â”‚   // Managed by JVM + GC
â”‚   â”‚   // Stores actual OBJECTS & ARRAYS
â”‚   â”‚   // Divided into Young & Old Gen
â”‚   â”‚   // GC frees memory here
â”‚   â”‚
â”‚   â”œâ”€ Metaspace (Native Memory)
â”‚   â”‚   // Allocated from OS RAM (outside Heap)
â”‚   â”‚   // Stores:
â”‚   â”‚   // - Class metadata
â”‚   â”‚   // - Static variables
â”‚   â”‚   // - Method info
â”‚   â”‚   // Freed when ClassLoader unloads classes
â”‚   â”‚
â”‚   â”œâ”€ PC Register (Per Thread)
â”‚   â”‚   // NOT in Heap or Stack
â”‚   â”‚   // Logical register (CPU-related)
â”‚   â”‚   // Stores address of current bytecode instruction
â”‚   â”‚   // Used during:
â”‚   â”‚   // - Context switching
â”‚   â”‚   // - Multithreading
â”‚   â”‚   // Updated EVERY instruction execution
â”‚   â”‚
â”‚   â””â”€ Native Method Stack
â”‚       // Allocated in OS RAM
â”‚       // Used when Java calls native (C/C++) code
â”‚       // Works with JNI
â”‚
â”œâ”€â”€ Execution Engine
â”‚   â”‚ // Uses CPU directly
â”‚   â”‚
â”‚   â”œâ”€ Interpreter
â”‚   â”‚   // Reads bytecode from memory
â”‚   â”‚   // Executes instruction-by-instruction
â”‚   â”‚   // Uses CPU for execution
â”‚   â”‚
â”‚   â”œâ”€ JIT Compiler
â”‚   â”‚   // Runs inside JVM
â”‚   â”‚   // Compiles hot bytecode â†’ native machine code
â”‚   â”‚   // Stores compiled code in Code Cache (RAM)
â”‚   â”‚
â”‚   â””â”€ Garbage Collector
â”‚       // Runs on CPU threads
â”‚       // Scans Heap in RAM
â”‚       // Frees unreachable objects
â”‚       // Stop-the-world or concurrent (GC dependent)
â”‚
â”œâ”€â”€ Code Cache (Native Memory)
â”‚   â”‚ // Allocated in OS RAM
â”‚   â”‚ // Stores JIT-compiled native code
â”‚   â”‚ // CPU executes directly from here
â”‚
â””â”€â”€ JNI (Java Native Interface)
    // Bridge between Java & native code
    // Allows JVM to call OS / C / C++ libraries
    // Uses Native Method Stack + CPU



Who manages what in JVM memory

| Memory Area                  | Managed By                       | Lives Where            | Notes                                                                                                 |
| ---------------------------- | -------------------------------- | ---------------------- | ----------------------------------------------------------------------------------------------------- |
| **Heap**                     | **JVM (Garbage Collector)**      | OS RAM                 | Stores all objects & arrays, GC frees unreachable objects, divided into Young + Old Gen               |
| **Stack (per thread)**       | **JVM**                          | OS RAM                 | Stores method frames, local primitives, references; auto-cleared when method returns; NOT GC-managed  |
| **Metaspace**                | **JVM (via ClassLoader unload)** | OS RAM (native memory) | Stores class metadata, static variables, method info; freed only when ClassLoader becomes unreachable |
| **Code Cache**               | **JVM**                          | OS RAM (native)        | Stores JIT-compiled native code; CPU executes directly                                                |
| **PC Register (per thread)** | **JVM + CPU**                    | CPU register           | Tracks current bytecode instruction; updated on each execution                                        |
| **Native Method Stack**      | **JVM**                          | OS RAM                 | Used for native method calls (C/C++ via JNI)                                                          |


ğŸ”‘ Key Points

All JVM memory areas are managed by JVM, not the OS directly.

OS provides raw RAM, JVM divides it into Heap, Stack, Metaspace, Code Cache, etc.

Heap â†’ GC cleans

Stack â†’ Auto-cleared when methods return

Metaspace â†’ Cleared when ClassLoader unloads

Code Cache â†’ Managed by JVM for JIT-compiled code

PC Register â†’ Used by CPU + JVM to track execution


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OS / RAM / CPU RELATIONSHIP (CRITICAL INTERVIEW POINTS)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â€¢ JVM = OS Process
â€¢ OS provides RAM â†’ JVM divides it into Heap, Stack, Metaspace
â€¢ CPU executes:
  - Interpreted bytecode
  - JIT compiled native code
â€¢ PC Register tracks current instruction per thread
â€¢ GC threads also consume CPU
â€¢ Heap & Metaspace live in RAM
â€¢ Stack lives in RAM (per thread)
â€¢ Code Cache lives in RAM
â€¢ Nothing runs without CPU
â€¢ Nothing stores without RAM



â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4ï¸âƒ£ JVM MEMORY ARCHITECTURE (DIAGRAM WITH INLINE COMMENTS ONLY)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Metaspace (Native Memory â€“ NOT Heap)                       â”‚
â”‚------------------------------------------------------------â”‚
â”‚ â€¢ Stores CLASS-LEVEL data                                  â”‚
â”‚ â€¢ Class metadata (name, methods, fields)                   â”‚
â”‚ â€¢ Static variables                                         â”‚
â”‚ â€¢ Method bytecode structure                                â”‚
â”‚                                                            â”‚
â”‚ Who manages it?                                            â”‚
â”‚ â€¢ JVM (NOT Garbage Collector)                              â”‚
â”‚                                                            â”‚
â”‚ How memory is freed?                                       â”‚
â”‚ â€¢ When ClassLoader unloads classes                         â”‚
â”‚ â€¢ Uses OS native memory                                    â”‚
â”‚                                                            â”‚
â”‚ Notes                                                      â”‚
â”‚ â€¢ Replaced PermGen (Java 8+)                               â”‚
â”‚ â€¢ Can grow dynamically        //Before java 8 in 6-7 - it was fixed size                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â–²
                â”‚ ClassLoader loads classes & metadata
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Heap Memory (GC Managed â€“ Shared)                          â”‚
â”‚------------------------------------------------------------â”‚
â”‚ â€¢ Stores ALL objects & arrays                              â”‚
â”‚ â€¢ Shared across all threads                                â”‚
â”‚                                                            â”‚
â”‚ Who manages it?                                            â”‚
â”‚ â€¢ Garbage Collector (G1 / ZGC / etc.)                      â”‚
â”‚                                                            â”‚
â”‚ How allocation works?                                      â”‚
â”‚ â€¢ Objects created via `new` go here                        â”‚
â”‚                                                            â”‚
â”‚  Young Generation                                         â”‚
â”‚  ----------------                                         â”‚
â”‚  â”œâ”€ Eden Space                                             â”‚
â”‚  â”‚   â€¢ New objects allocated                               â”‚
â”‚  â”‚   â€¢ Cleaned by Minor GC                                 â”‚
â”‚  â”‚                                                        â”‚
â”‚  â”œâ”€ Survivor S0 / S1                                      â”‚
â”‚  â”‚   â€¢ Objects that survived Minor GC                     â”‚
â”‚  â”‚   â€¢ Objects age here                                   â”‚
â”‚                                                            â”‚
â”‚  Old / Tenured Generation                                  â”‚
â”‚  -----------------------                                  â”‚
â”‚  â€¢ Long-lived objects                                      â”‚
â”‚  â€¢ Cleaned by Major / Full GC                              â”‚
â”‚                                                            â”‚
â”‚  String Pool (inside Heap)                                 â”‚
â”‚  ---------------------------                               â”‚
â”‚  â€¢ Stores interned String literals                         â”‚
â”‚  â€¢ Only one copy per literal                               â”‚
â”‚                                                            â”‚
â”‚ How memory is freed?                                       â”‚
â”‚ â€¢ GC removes unreachable objects                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â–²
                â”‚ Stack holds references to Heap objects
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stack Memory (Per Thread â€“ NOT GC Managed)                 â”‚
â”‚------------------------------------------------------------â”‚
â”‚ â€¢ Each thread has its OWN stack                            â”‚
â”‚                                                            â”‚
â”‚ Who manages it?                                            â”‚
â”‚ â€¢ JVM automatically                                       â”‚
â”‚                                                            â”‚
â”‚ What lives here?                                           â”‚
â”‚ â€¢ Method call frames                                       â”‚
â”‚ â€¢ Local primitive variables                                â”‚
â”‚ â€¢ References to Heap objects                               â”‚
â”‚                                                            â”‚
â”‚ How memory is freed?                                       â”‚
â”‚ â€¢ When method returns                                     â”‚
â”‚ â€¢ When thread terminates                                   â”‚
â”‚                                                            â”‚
â”‚ Errors                                                     â”‚
â”‚ â€¢ StackOverflowError â†’ deep recursion                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Code Cache (Native Memory)                                 â”‚
â”‚------------------------------------------------------------â”‚
â”‚ â€¢ Stores JIT compiled native machine code                  â”‚
â”‚                                                            â”‚
â”‚ Who manages it?                                            â”‚
â”‚ â€¢ JVM JIT Compiler                                         â”‚
â”‚                                                            â”‚
â”‚ How it works?                                              â”‚
â”‚ â€¢ Hot bytecode â†’ compiled â†’ stored here                   â”‚
â”‚ â€¢ CPU executes directly                                   â”‚
â”‚                                                            â”‚
â”‚ Why needed?                                                â”‚
â”‚ â€¢ Improves performance over time                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ‘‰ Facts:
â€¢ Heap â†’ shared across threads
â€¢ Stack â†’ per thread
â€¢ GC works ONLY on Heap

/*
================================================================================
OBJECT CREATION + GARBAGE COLLECTION (GC) FLOW â€” COMPLETE LOGIC VIEW
Author : Shivam
Purpose: Understand HOW objects are created, WHERE they go, WHEN GC runs,
         WHO decides, and HOW memory is finally freed (INTERVIEW + REAL WORLD)
================================================================================
*/

/*
================================================================================
1ï¸âƒ£ OBJECT CREATION â€” STEP BY STEP
================================================================================
*/
/*
new Object()
â”‚
// JVM Execution Engine receives bytecode instruction: new
â”‚
â”œâ”€â–º Check Thread Local Allocation Buffer (TLAB)
â”‚     // Small private Eden area per thread
â”‚
â”‚     if (TLAB has enough space)
â”‚         â†’ allocate object in Eden via TLAB (FAST, no lock)
â”‚
â”‚     else
â”‚         â†’ check Eden free space
â”‚
â”œâ”€â–º Eden Space (Young Generation, Heap)
â”‚     // FIRST allocation area for almost all objects
â”‚     // Managed by JVM Garbage Collector
â”‚
â”‚     if (Eden has enough contiguous space)
â”‚         â†’ allocate object in Eden
â”‚
â”‚     else
â”‚         â†’ trigger Minor GC
â”‚
â–¼
Object created successfully
// Reference stored in Stack frame of the thread
// Object itself lives in Heap (Eden)

// /*
// ================================================================================
// 2ï¸âƒ£ MINOR GC â€” WHEN & WHY
// ================================================================================
// */

// Trigger Condition:
// ------------------
// Eden Space FULL â†’ Minor GC (mandatory)

// Who triggers:
// -------------
// JVM Garbage Collector (Execution Engine)

// Why Minor GC:
// -------------
// â€¢ Eden fills very fast (short-lived objects)
// â€¢ Free space for new allocations

// /*
// ================================================================================
// 3ï¸âƒ£ MINOR GC â€” INTERNAL LOGIC
// ================================================================================
// */

// Minor GC Process:
// -----------------
// 1. Identify GC Roots
//    â€¢ Stack references (local variables)
//    â€¢ Static fields (from Metaspace)
//    â€¢ CPU registers (PC Register)
//    â€¢ JNI references

// 2. Reachability Analysis
//    â€¢ Reachable objects â†’ ALIVE
//    â€¢ Unreachable objects â†’ DEAD

// 3. Object Movement
//    â€¢ DEAD objects in Eden â†’ REMOVED (memory freed)
//    â€¢ ALIVE objects â†’
//          Eden â†’ Survivor Space (S0 or S1)
//          object.age++

// 4. Eden is completely cleared

// // Stop-The-World (very short pause)

// /*
// ================================================================================
// 4ï¸âƒ£ SURVIVOR SPACE (S0 / S1) â€” AGE & FLIP LOGIC
// ================================================================================
// */

// // Survivor Rules:
// // ---------------
// // â€¢ Two survivor spaces: S0 and S1
// // â€¢ Only ONE survivor space active at a time

// // After each Minor GC:
// // --------------------
// // Eden + Active Survivor â†’ Empty Survivor

// // Object Age:
// // -----------
// // â€¢ Each object carries an age counter
// // â€¢ Age increments after every Minor GC

// /*
// ================================================================================
// 5ï¸âƒ£ PROMOTION TO OLD GENERATION â€” DECISION LOGIC
// ================================================================================
// */

// An object is promoted to Old Generation if:

// Rule 1:
// -------
// object.age >= MaxTenuringThreshold (default â‰ˆ 15)

// Rule 2:
// -------
// Survivor Space is FULL

// Rule 3:
// -------
// Object is very large (bypasses Survivor)

// Result:
// -------
// Object copied into Old / Tenured Generation
// // Old Gen is GCâ€™d less frequently

// /*
// ================================================================================
// 6ï¸âƒ£ MAJOR / FULL GC â€” WHEN & HOW
// ================================================================================
// */

// Trigger Conditions:
// ------------------
// â€¢ Old Generation almost FULL
// â€¢ Promotion failure
// â€¢ Explicit System.gc() (hint only)

// Major GC Process:
// -----------------
// â€¢ Full Heap scan (Young + Old)
// â€¢ Identify unreachable objects
// â€¢ Remove dead objects from Old Gen
// â€¢ Optional memory compaction

// // Stop-The-World (long pause)

// /*
// ================================================================================
// 7ï¸âƒ£ MEMORY FREEING â€” IMPORTANT TRUTH
// ================================================================================
// */

// â€¢ GC frees memory ONLY in Heap
// â€¢ Stack memory auto-cleared on method return
// â€¢ Metaspace cleared when ClassLoader unloaded
// â€¢ Code Cache cleared by JVM internally

// /*
// ================================================================================
// 8ï¸âƒ£ WHY THIS DESIGN WORKS (CORE IDEA)
// ================================================================================
// */

// â€¢ 90% objects die young â†’ cheap Minor GC
// â€¢ Long-lived objects moved to Old Gen
// â€¢ Less frequent expensive GC on Old Gen
// â€¢ High throughput + optimized memory use

// /*
// ================================================================================
// 9ï¸âƒ£ COMPLETE FLOW â€” ONE LOOK
// ================================================================================
// */

// new Object()
//    â†“
// TLAB â†’ Eden
//    â†“
// Eden full?
//    â†“ YES
// Minor GC
//    â”œâ”€ unreachable â†’ delete
//    â””â”€ reachable â†’ Survivor (age++)
//           â†“
// Age threshold / Survivor full?
//           â†“ YES
//         Old Gen
//           â†“
// Old Gen full?
//           â†“ YES
//        Major GC

// /*
// ================================================================================
// ğŸ”Ÿ INTERVIEW ONE-LINER
// ================================================================================
// */

// "Objects are first allocated in Eden. When Eden fills, Minor GC runs and live
// objects are moved to Survivor spaces. Objects surviving multiple Minor GCs or
// unable to fit in Survivor spaces are promoted to Old Generation, where Major GC
// runs less frequently to reclaim long-lived objects."

// /*
// ================================================================================
// END â€” OBJECT CREATION & GC FLOW CHEAT-SHEET
// ================================================================================


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 6ï¸âƒ£ STRING MEMORY EXPLAINED
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// String a = "java";
// â€¢ Stored in String Pool (Heap)

// String b = new String("java");
// â€¢ New object in Heap (NOT pooled)

// b.intern();
// â€¢ Returns reference from String Pool

// Only STRING literals are pooled
// Primitives are NOT pooled

// Boxed primitives:
// Integer.valueOf(-128 to 127) â†’ cached

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 7ï¸âƒ£ MEMORY LEAK vs OUT OF MEMORY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Memory Leak Example:
// List<String> list = new ArrayList<>();
// while(true) {
//     list.add("leak");
// }

// â€¢ Objects still referenced
// â€¢ GC cannot free
// â€¢ Heap fills
// â€¢ Eventually â†’ OutOfMemoryError

// Memory Leak = Cause
// OOM Error    = Result

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 8ï¸âƒ£ GARBAGE COLLECTION TYPES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Minor GC
// â€¢ Cleans Young Generation
// â€¢ Fast & frequent

// Major / Full GC
// â€¢ Cleans Old Generation
// â€¢ Slow, Stop-The-World

// GC Implementations
// â€¢ Serial GC      â†’ small apps
// â€¢ Parallel GC    â†’ throughput-oriented
// â€¢ G1 GC          â†’ balanced (DEFAULT)
// â€¢ ZGC            â†’ ultra-low latency
// â€¢ Shenandoah     â†’ concurrent low pause
// â€¢ CMS            â†’ deprecated

// System.gc()
// â€¢ Only a REQUEST
// â€¢ JVM may ignore

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 9ï¸âƒ£ IMPORTANT JVM FLAGS (COMMON)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// -Xms       â†’ Initial heap size
// -Xmx       â†’ Max heap size
// -XX:+UseG1GC
// -XX:+UseZGC
// -XX:MaxMetaspaceSize
// -XX:+PrintGCDetails

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ”Ÿ ONE-LINE EXECUTION SUMMARY (INTERVIEW GOLD)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// .java
//  â†’ javac
//  â†’ .class (bytecode)
//  â†’ java
//  â†’ JVM
//  â†’ ClassLoader
//  â†’ Verifier
//  â†’ Interpreter + JIT
//  â†’ Heap / Stack / Metaspace
//  â†’ GC
//  â†’ CPU
//  â†’ Output

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ”¥ GOLDEN INTERVIEW FACTS (RAPID FIRE)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â€¢ JDK = JRE + Dev Tools
// â€¢ JRE = JVM + Libraries
// â€¢ JVM is platform dependent
// â€¢ Bytecode is platform independent
// â€¢ GC manages only Heap
// â€¢ Stack is per-thread
// â€¢ String Pool is inside Heap
// â€¢ Metaspace uses native memory
// â€¢ JIT improves performance over time
// â€¢ Memory leak â‰  OOM
// â€¢ Objects die only when unreachable

// ================================================================================
// âœ… END â€” COMPLETE JAVA CHEAT-SHEET IN ONE CODE WINDOW
// ================================================================================
// */
